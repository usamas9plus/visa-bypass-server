#!/usr/bin/env python3
"""
Build Encrypted Extension Package
This script packages all extension files, compresses and encrypts them.
The output is a Python file with embedded encrypted data.
Includes JS Obfuscation step.
"""

import os
import io
import shutil
import json
import base64
import zipfile
import hashlib
import subprocess
from pathlib import Path

# Encryption key derived from passphrase (DO NOT SHARE)
ENCRYPTION_KEY = "vecna-extension-secret-key-2024"

def xor_encrypt(data: bytes, key: str) -> bytes:
    """Simple XOR encryption with key stretching."""
    # Stretch key to match data length
    key_bytes = (key * ((len(data) // len(key)) + 1))[:len(data)].encode()
    return bytes(a ^ b for a, b in zip(data, key_bytes))

def get_extension_files():
    """Get list of files relative to extension root."""
    return [
        "manifest.json",
        "background.js",
        "popup.html",
        "popup.js",
        "content.js",
        "injector.js",
        "fg_sp.js",
        "ui_polyfill.js",

        "icons/vecna_16.png",
        "icons/vecna_48.png",
        "icons/vecna_128.png",
    ]

def prepare_dist_folder():
    """Copy files to temporary dist folder for processing."""
    root_dir = Path(__file__).parent
    dist_dir = root_dir / "dist_temp"
    
    # Clean previous build
    if dist_dir.exists():
        shutil.rmtree(dist_dir)
    dist_dir.mkdir()
    
    # Create icons dir
    (dist_dir / "icons").mkdir()
    
    files = get_extension_files()
    valid_files = []
    
    for f in files:
        src = root_dir / f
        dst = dist_dir / f
        
        if src.exists():
            shutil.copy2(src, dst)
            valid_files.append((f, dst))
        else:
            print(f"  Warning: {f} not found")
            
    return dist_dir, valid_files

def obfuscate_js(dist_dir):
    """Run javascript-obfuscator on the dist folder."""
    print("        Running obfuscation on dist folder...")
    
    js_files = ["background.js", "content.js", "fg_sp.js", "popup.js", "injector.js", "ui_polyfill.js"]
    
    # Check for npx/node availability
    try:
        subprocess.run(["npx", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)
    except:
        print("        [!] WARNING: npx not found. Skipping obfuscation.")
        return

    for js in js_files:
        target = dist_dir / js
        if target.exists():
            try:
                # High obfuscation options
                cmd = [
                    "npx", "javascript-obfuscator", 
                    str(target),
                    "--output", str(target),
                    "--compact", "true",
                    "--control-flow-flattening", "true",
                    "--dead-code-injection", "true",
                    "--string-array", "true",
                    "--string-array-encoding", "rc4"
                ]
                # Shell=True needed on Windows for npx
                subprocess.run(cmd, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                print(f"        Obfuscated: {js}")
            except Exception as e:
                print(f"        [!] Failed to obfuscate {js}: {e}")

def create_zip_package(files_list):
    """Create in-memory ZIP archive from list of (rel_path, full_path)."""
    zip_buffer = io.BytesIO()
    
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
        for rel_path, full_path in files_list:
            print(f"    Adding: {rel_path}")
            with open(full_path, 'rb') as f:
                zf.writestr(rel_path, f.read())
    
    return zip_buffer.getvalue()

def main():
    print("=" * 60)
    print("  BUILD ENCRYPTED EXTENSION PACKAGE (OBFUSCATED)")
    print("=" * 60)
    print()
    
    # Prepare Dist
    print("  [1/5] Preparing temporary dist folder...")
    dist_dir, valid_files = prepare_dist_folder()
    print(f"        Copied {len(valid_files)} files to {dist_dir.name}")
    print()
    
    # Obfuscate
    print("  [2/5] Obfuscating JavaScript code...")
    obfuscate_js(dist_dir)
    print()
    
    # Create ZIP
    print("  [3/5] Creating ZIP archive...")
    zip_data = create_zip_package(valid_files)
    print(f"        ZIP size: {len(zip_data)} bytes")
    print()
    
    # Encrypt
    print("  [4/5] Encrypting...")
    encrypted_data = xor_encrypt(zip_data, ENCRYPTION_KEY)
    print(f"        Encrypted size: {len(encrypted_data)} bytes")
    print()
    
    # Base64 encode for embedding
    encoded_data = base64.b64encode(encrypted_data).decode('ascii')
    
    # Calculate hash for integrity check
    data_hash = hashlib.sha256(zip_data).hexdigest()[:16]
    
    # Generate output Python code
    output_code = f'''# Auto-generated encrypted extension data
# DO NOT EDIT - Generated by build_encrypted.py
# Contains OBFUSCATED and ENCRYPTED extension code

ENCRYPTED_EXTENSION_DATA = """{encoded_data}"""

EXTENSION_HASH = "{data_hash}"
'''
    
    # Write to file
    output_path = Path(__file__).parent / "extension_data.py"
    with open(output_path, 'w') as f:
        f.write(output_code)
        
    # Cleanup
    try:
        shutil.rmtree(dist_dir)
        print("        Cleaned up temporary files")
    except:
        pass
    
    print(f"  [5/5] Created: extension_data.py")
    print(f"        Data size: {len(encoded_data)} characters")
    print(f"        Hash: {data_hash}")
    print()
    print("  SUCCESS! Now run: python vecna_license.py")
    print()

if __name__ == "__main__":
    main()
